use log::{debug, error, info};
use std::collections::HashMap;
use std::io::Write;
use std::path::PathBuf;

pub struct Properties {
	pub file: PathBuf,
	pub items: HashMap<String, String>,
}

impl Properties {
	/// Creates a new `Properties` object by loading properties from the given file.
	///
	/// # Arguments
	///
	/// * `file` - A string slice representing the path to the properties file.
	///
	/// # Returns
	///
	/// A `Result` which is:
	/// - `Ok`: Contains the `Properties` object.
	/// - `Err`: Contains an error message if the file cannot be loaded.
	pub fn new(file: &PathBuf) -> Result<Self, String> {
		debug!(
            "Creating new Properties object with file: {}",
            file.to_str().unwrap()
        );
		let map = match Properties::load(file) {
			Ok(map) => map,
			Err(e) => {
				error!("Error loading properties file: {}", e);
				return Err(format!("Error loading properties file: {}", e));
			}
		};
		Ok(Self {
			file: file.clone(),
			items: map,
		})
	}

	/// Gets the property value associated with the given key.
	///
	/// # Arguments
	///
	/// * `key` - A string slice representing the key.
	///
	/// # Returns
	///
	/// An `Option` which is:
	/// - `Some`: Contains the value associated with the key.
	/// - `None`: If the key does not exist.
	pub fn get(&self, key: &str) -> Option<&String> {
		debug!("Getting property for key: {}", key);
		self.items.get(key)
	}

	/// Sets the property value for the given key.
	///
	/// # Arguments
	///
	/// * `key` - A string slice representing the key.
	/// * `value` - A string slice representing the value.
	pub fn set(&mut self, key: &str, value: &str) {
		let result = self.items.insert(key.to_string(), value.to_string());
		debug!(
            "Setting property {} from {} to {}",
            key,
            result.unwrap_or("null".to_string()),
            value
        );
	}

	/// Writes the properties to the file specified in the `file` attribute.
	///
	/// # Returns
	///
	/// A `Result` which is:
	/// - `Ok`: If the file was written successfully.
	/// - `Err`: Contains an error message if writing to the file fails.
	pub fn write(&self) -> Result<(), String> {
		debug!(
            "Writing properties to file: {}",
            self.file.to_str().unwrap()
        );
		let mut file = match std::fs::File::create(&self.file) {
			Ok(file) => file,
			Err(e) => {
				error!("Error creating properties file: {}", e);
				return Err(format!("Error creating properties file: {}", e));
			}
		};
		let mut lines: String =
			"# Minecraft Server Properties\n# Generated By Obsidian Server Portal\n".to_string();
		for (key, value) in &self.items {
			lines += format!("{}={}\n", key, value).as_str();
		}
		match file.write_all(lines.as_bytes()) {
			Ok(_) => (),
			Err(e) => {
				error!("Error writing to properties file: {}", e);
				return Err(format!("Error writing to properties file: {}", e));
			}
		}
		debug!("Successfully wrote properties to file: {:?}", self.file);
		Ok(())
	}

	/// Loads properties from the specified file.
	///
	/// # Arguments
	///
	/// * `file` - A string slice representing the path to the properties file.
	///
	/// # Returns
	///
	/// A `Result` which is:
	/// - `Ok`: Contains a `HashMap` with the properties.
	/// - `Err`: Contains an error message if the file cannot be read or parsed.
	pub fn load(file: &PathBuf) -> Result<HashMap<String, String>, String> {
		info!("Loading properties file: {:?}", file);

		if !file.exists() {
			debug!("Properties file does not exist, creating empty properties");
			return Ok(HashMap::new());
		}

		let mut map = HashMap::new();
		let file_content = match std::fs::read_to_string(file) {
			Ok(content) => content,
			Err(e) => {
				error!("Error reading properties file: {}", e);
				return Err(format!("Error reading properties file: {}", e));
			}
		};
		for line in file_content.lines() {
			let parts: Vec<&str> = line.split('=').collect();
			if parts.len() == 2 {
				map.insert(parts[0].to_string(), parts[1].to_string());
			}
		}
		debug!("Loaded {} properties", map.len());
		Ok(map)
	}
}
